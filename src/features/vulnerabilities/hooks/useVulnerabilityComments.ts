import { useState, useEffect, useCallback } from 'react';
import {
  CommentDTO,
  CreateCommentInput,
  UpdateCommentInput,
  CommentListParams,
  CommentStats
} from '../types';

interface UseVulnerabilityCommentsOptions {
  vulnerabilityId: number;
  includeReplies?: boolean;
  includeDeleted?: boolean;
  sortOrder?: 'asc' | 'desc';
  limit?: number;
  autoRefresh?: boolean;
  refreshInterval?: number;
}

interface UseVulnerabilityCommentsReturn {
  // 数据状态
  comments: CommentDTO[];
  stats: CommentStats | null;
  loading: boolean;
  error: string | null;

  // 操作方法
  refreshComments: () => Promise<void>;
  addComment: (
    input: Omit<CreateCommentInput, 'vulnerabilityId'>
  ) => Promise<CommentDTO | null>;
  updateComment: (
    commentId: number,
    input: UpdateCommentInput
  ) => Promise<CommentDTO | null>;
  deleteComment: (commentId: number) => Promise<boolean>;

  // 状态管理
  isSubmitting: boolean;
  clearError: () => void;
}

export function useVulnerabilityComments(
  options: UseVulnerabilityCommentsOptions
): UseVulnerabilityCommentsReturn {
  const {
    vulnerabilityId,
    includeReplies = true,
    includeDeleted = false,
    sortOrder = 'asc',
    limit = 50,
    autoRefresh = false,
    refreshInterval = 30000 // 30秒
  } = options;

  // 状态管理
  const [comments, setComments] = useState<CommentDTO[]>([]);
  const [stats, setStats] = useState<CommentStats | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // 构建API URL
  const getCommentsUrl = useCallback(() => {
    const params = new URLSearchParams({
      includeReplies: includeReplies.toString(),
      includeDeleted: includeDeleted.toString(),
      sortOrder,
      limit: limit.toString()
    });
    return `/api/vulnerabilities/${vulnerabilityId}/comments?${params.toString()}`;
  }, [vulnerabilityId, includeReplies, includeDeleted, sortOrder, limit]);

  // 获取评论列表
  const fetchComments = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10秒超时

      const response = await fetch(getCommentsUrl(), {
        signal: controller.signal,
        headers: {
          'Cache-Control': 'no-cache'
        }
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const result = await response.json();

      if (result.status === 'success') {
        setComments(result.data.comments || []);
        setStats(result.data.stats || null);
      } else {
        throw new Error(
          result.data?.message || result.message || '获取评论失败'
        );
      }
    } catch (err) {
      let errorMessage = '获取评论失败';

      if (err instanceof Error) {
        if (err.name === 'AbortError') {
          errorMessage = '请求超时，请重试';
        } else if (err.message.includes('Failed to fetch')) {
          errorMessage = '网络连接失败，请检查网络后重试';
        } else {
          errorMessage = err.message;
        }
      }

      setError(errorMessage);
      console.error('获取评论失败:', err);
    } finally {
      setLoading(false);
    }
  }, [getCommentsUrl]);

  // 刷新评论
  const refreshComments = useCallback(async () => {
    await fetchComments();
  }, [fetchComments]);

  // 添加评论
  const addComment = useCallback(
    async (
      input: Omit<CreateCommentInput, 'vulnerabilityId'>
    ): Promise<CommentDTO | null> => {
      try {
        setIsSubmitting(true);
        setError(null);

        const response = await fetch(
          `/api/vulnerabilities/${vulnerabilityId}/comments`,
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              ...input,
              vulnerabilityId
            })
          }
        );

        const result = await response.json();

        if (result.status === 'success') {
          const newComment: CommentDTO = result.data;

          // 如果是回复，找到父评论并添加到replies中
          if (newComment.parentId) {
            setComments((prevComments) =>
              prevComments.map((comment) =>
                comment.id === newComment.parentId
                  ? { ...comment, replies: [...comment.replies, newComment] }
                  : comment
              )
            );
          } else {
            // 如果是顶级评论，根据排序插入到合适位置
            setComments((prevComments) => {
              const newComments = [...prevComments, newComment];
              return sortOrder === 'asc'
                ? newComments.sort(
                    (a, b) =>
                      new Date(a.createdAt).getTime() -
                      new Date(b.createdAt).getTime()
                  )
                : newComments.sort(
                    (a, b) =>
                      new Date(b.createdAt).getTime() -
                      new Date(a.createdAt).getTime()
                  );
            });
          }

          // 更新统计信息
          if (stats) {
            setStats({
              ...stats,
              total: stats.total + 1,
              internal: newComment.isInternal
                ? stats.internal + 1
                : stats.internal,
              external: newComment.isInternal
                ? stats.external
                : stats.external + 1,
              replies: newComment.parentId ? stats.replies + 1 : stats.replies,
              lastCommentAt: newComment.createdAt
            });
          }

          return newComment;
        } else {
          throw new Error(
            result.data?.message || result.message || '添加评论失败'
          );
        }
      } catch (err) {
        const errorMessage =
          err instanceof Error ? err.message : '添加评论失败';
        setError(errorMessage);
        console.error('添加评论失败:', err);
        return null;
      } finally {
        setIsSubmitting(false);
      }
    },
    [vulnerabilityId, sortOrder, stats]
  );

  // 更新评论
  const updateComment = useCallback(
    async (
      commentId: number,
      input: UpdateCommentInput
    ): Promise<CommentDTO | null> => {
      try {
        setIsSubmitting(true);
        setError(null);

        const response = await fetch(
          `/api/vulnerabilities/${vulnerabilityId}/comments/${commentId}`,
          {
            method: 'PATCH',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(input)
          }
        );

        const result = await response.json();

        if (result.status === 'success') {
          const updatedComment: CommentDTO = result.data;

          // 更新评论列表中的对应评论
          setComments((prevComments) =>
            prevComments.map((comment) => {
              if (comment.id === commentId) {
                return updatedComment;
              }
              // 检查是否在回复中
              if (comment.replies.some((reply) => reply.id === commentId)) {
                return {
                  ...comment,
                  replies: comment.replies.map((reply) =>
                    reply.id === commentId ? updatedComment : reply
                  )
                };
              }
              return comment;
            })
          );

          return updatedComment;
        } else {
          throw new Error(
            result.data?.message || result.message || '更新评论失败'
          );
        }
      } catch (err) {
        const errorMessage =
          err instanceof Error ? err.message : '更新评论失败';
        setError(errorMessage);
        console.error('更新评论失败:', err);
        return null;
      } finally {
        setIsSubmitting(false);
      }
    },
    [vulnerabilityId]
  );

  // 删除评论
  const deleteComment = useCallback(
    async (commentId: number): Promise<boolean> => {
      try {
        setIsSubmitting(true);
        setError(null);

        const response = await fetch(
          `/api/vulnerabilities/${vulnerabilityId}/comments/${commentId}`,
          {
            method: 'DELETE'
          }
        );

        const result = await response.json();

        if (result.status === 'success') {
          // 从评论列表中移除已删除的评论
          setComments((prevComments) =>
            prevComments.reduce<CommentDTO[]>((acc, comment) => {
              if (comment.id === commentId) {
                // 跳过被删除的顶级评论
                return acc;
              }

              // 过滤掉被删除的回复
              const filteredReplies = comment.replies.filter(
                (reply) => reply.id !== commentId
              );

              acc.push({
                ...comment,
                replies: filteredReplies
              });
              return acc;
            }, [])
          );

          // 更新统计信息
          if (stats) {
            setStats({
              ...stats,
              total: stats.total - 1
              // 注意：这里需要知道被删除评论的类型才能准确更新统计
              // 为简化处理，这里先保持原值，实际应用中可能需要重新获取统计信息
            });
          }

          return true;
        } else {
          throw new Error(
            result.data?.message || result.message || '删除评论失败'
          );
        }
      } catch (err) {
        const errorMessage =
          err instanceof Error ? err.message : '删除评论失败';
        setError(errorMessage);
        console.error('删除评论失败:', err);
        return false;
      } finally {
        setIsSubmitting(false);
      }
    },
    [vulnerabilityId, stats]
  );

  // 清除错误
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  // 初始加载
  useEffect(() => {
    if (vulnerabilityId) {
      fetchComments();
    }
  }, [vulnerabilityId, fetchComments]);

  // 自动刷新
  useEffect(() => {
    if (!autoRefresh || !vulnerabilityId || loading) return;

    const intervalId = setInterval(() => {
      // 只有在没有正在加载时才执行自动刷新
      if (!loading) {
        fetchComments();
      }
    }, refreshInterval);

    return () => clearInterval(intervalId);
  }, [autoRefresh, refreshInterval, vulnerabilityId, loading, fetchComments]);

  return {
    // 数据状态
    comments,
    stats,
    loading,
    error,

    // 操作方法
    refreshComments,
    addComment,
    updateComment,
    deleteComment,

    // 状态管理
    isSubmitting,
    clearError
  };
}
