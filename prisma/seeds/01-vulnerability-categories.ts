import { PrismaClient } from '@prisma/client';
import * as fs from 'fs';
import * as path from 'path';

const prisma = new PrismaClient();

/**
 * 原始分类数据类型（来自JSON文件）
 */
interface RawCategory {
  Id: number;
  Pid: number;
  Name: string;
  State: number;
}

/**
 * CWE映射数据类型
 */
interface CategoryMapping {
  rootCause?: string;
  technicalCategory?: string;
  cweId?: string;
  owaspCategory?: string;
  testingMethod?: string;
  remediation?: string;
}

/**
 * 转换后的分类类型
 */
interface ConvertedCategory {
  id: number;
  name: string;
  description: string;
  parentId: number | null;
  level: number;
  sort: number;
  isActive: boolean;
  isLeaf: boolean;
  rootCause: string | null;
  technicalCategory: string | null;
  cweId: string | null;
  owaspCategory: string | null;
  testingMethod: string | null;
  remediationTemplate: string | null;
  usageCount: number;
  lastUsedAt: null;
}

/**
 * 漏洞分类种子数据
 *
 * 功能：
 * 1. 导入97个漏洞分类（7个顶层 + 90个子分类）
 * 2. 建立5大根因分类映射
 * 3. 添加CWE和OWASP标准映射
 * 4. 支持幂等性操作（可重复执行）
 */

/**
 * 直接使用原始数字ID，无需转换
 */

/**
 * 根据分类名称生成默认描述
 */
function generateDescription(name: string, parentName?: string): string {
  const descriptions: Record<string, string> = {
    WEB漏洞: 'Web应用程序相关的安全漏洞',
    PC客户端漏洞: 'PC客户端软件相关的安全漏洞',
    移动及IOT智能: '移动应用和物联网设备相关的安全漏洞',
    服务器漏洞: '服务器系统和服务相关的安全漏洞',
    技术情报: '安全技术情报和威胁信息',
    业务情报: '业务安全相关的情报信息',
    SQL注入: '通过在应用程序输入中注入恶意SQL语句，获取未授权的数据访问',
    反射型XSS: '跨站脚本攻击，恶意脚本在用户浏览器中执行但不存储在服务器',
    存储型XSS: '跨站脚本攻击，恶意脚本存储在服务器并在其他用户访问时执行',
    命令注入: '通过注入系统命令获取服务器控制权',
    命令执行: '直接执行系统命令的安全漏洞',
    代码执行: '执行任意代码的安全漏洞',
    XXE注入: 'XML外部实体注入，可导致文件读取或SSRF',
    SSRF: '服务端请求伪造，诱使服务器访问内部资源',
    文件上传: '不安全的文件上传可能导致代码执行',
    文件包含: '包含恶意文件导致代码执行',
    文件读取: '未授权读取服务器文件',
    目录遍历: '通过路径遍历访问受限目录',
    CSRF: '跨站请求伪造，诱使用户执行非预期操作',
    信息泄露: '敏感信息的不当暴露',
    越权查询漏洞: '未经授权查询其他用户数据',
    越权删除漏洞: '未经授权删除其他用户数据',
    越权修改漏洞: '未经授权修改其他用户数据',
    越权新增漏洞: '未经授权为其他用户创建数据',
    垂直越权漏洞: '低权限用户访问高权限功能',
    弱口令: '使用容易猜测的密码',
    反序列化: '不安全的反序列化可能导致远程代码执行',
    URL跳转: '开放重定向漏洞，可用于钓鱼攻击',
    逻辑漏洞: '业务逻辑设计或实现缺陷',
    短信轰炸漏洞: '短信发送接口缺少频率限制',
    支付漏洞: '支付流程的安全缺陷',
    条件竞争漏洞: '并发操作导致的安全问题'
  };

  if (descriptions[name]) {
    return descriptions[name];
  }

  // 生成默认描述
  if (parentName) {
    return `${parentName}中的${name}相关安全漏洞`;
  }
  return `${name}相关的安全漏洞或安全问题`;
}

/**
 * 执行漏洞分类种子数据
 */
export async function seedVulnerabilityCategories() {
  console.log('🔄 开始导入漏洞分类数据...');

  try {
    // 读取原始分类数据
    const rawDataPath = path.join(
      __dirname,
      'data',
      'vulnerability-categories.json'
    );
    const rawData = JSON.parse(fs.readFileSync(rawDataPath, 'utf-8'));

    // 读取CWE映射数据
    const mappingPath = path.join(
      __dirname,
      'data',
      'category-cwe-mappings.json'
    );
    const cweMappings = JSON.parse(fs.readFileSync(mappingPath, 'utf-8'));

    // 验证数据
    if (!rawData.data || !Array.isArray(rawData.data)) {
      throw new Error('无效的分类数据格式');
    }

    const categories = rawData.data;
    console.log(`  📊 找到 ${categories.length} 个分类`);

    // 建立名称到父名称的映射
    const nameToParentName = new Map<string, string>();
    categories.forEach((cat: RawCategory) => {
      if (cat.Pid !== 0) {
        const parent = categories.find((p: RawCategory) => p.Id === cat.Pid);
        if (parent) {
          nameToParentName.set(cat.Name, parent.Name);
        }
      }
    });

    // 转换数据格式
    const convertedCategories = categories.map((cat: RawCategory) => {
      const parentName = nameToParentName.get(cat.Name);
      const mapping: CategoryMapping = cweMappings[cat.Name] || {};

      return {
        id: cat.Id,
        name: cat.Name,
        description: generateDescription(cat.Name, parentName),
        parentId: cat.Pid === 0 ? null : cat.Pid,
        level: cat.Pid === 0 ? 1 : 2, // 简化处理，只有两层
        sort: cat.Id, // 使用原始ID作为排序值
        isActive: cat.State === 1,
        isLeaf: !categories.some((c: RawCategory) => c.Pid === cat.Id), // 没有子分类则为叶子节点

        // 映射字段
        rootCause: mapping.rootCause || null,
        technicalCategory: mapping.technicalCategory || null,
        cweId: mapping.cweId || null,
        owaspCategory: mapping.owaspCategory || null,
        testingMethod: mapping.testingMethod || null,
        remediationTemplate: mapping.remediation || null,

        // 统计字段
        usageCount: 0,
        lastUsedAt: null
      };
    });

    // 分离顶层和子分类
    const topLevelCategories = convertedCategories.filter(
      (c: ConvertedCategory) => c.parentId === null
    );
    const childCategories = convertedCategories.filter(
      (c: ConvertedCategory) => c.parentId !== null
    );

    console.log(`  📁 顶层分类: ${topLevelCategories.length} 个`);
    console.log(`  📂 子分类: ${childCategories.length} 个`);

    // 使用事务执行数据操作
    const result = await prisma.$transaction(async (tx) => {
      // 1. 删除所有现有分类（如果存在）
      const deleted = await tx.vulnerabilityCategory.deleteMany();
      console.log(`  🗑️  删除了 ${deleted.count} 个旧分类`);

      // 2. 批量插入顶层分类
      const topResult = await tx.vulnerabilityCategory.createMany({
        data: topLevelCategories,
        skipDuplicates: true
      });
      console.log(`  ✅ 创建了 ${topResult.count} 个顶层分类`);

      // 3. 批量插入子分类
      const childResult = await tx.vulnerabilityCategory.createMany({
        data: childCategories,
        skipDuplicates: true
      });
      console.log(`  ✅ 创建了 ${childResult.count} 个子分类`);

      return {
        topLevel: topResult.count,
        children: childResult.count,
        total: topResult.count + childResult.count
      };
    });

    // 统计映射情况
    const mappedCategories = convertedCategories.filter(
      (c: ConvertedCategory) => c.cweId !== null
    );
    const rootCauseCategories = convertedCategories.filter(
      (c: ConvertedCategory) => c.rootCause !== null
    );

    console.log('\n📊 导入统计:');
    console.log(`  📝 总分类数: ${result.total}`);
    console.log(`  🔗 CWE映射: ${mappedCategories.length} 个`);
    console.log(`  🎯 根因映射: ${rootCauseCategories.length} 个`);

    // 显示5大根因分布
    const rootCauseStats = new Map<string, number>();
    rootCauseCategories.forEach((cat: ConvertedCategory) => {
      const count = rootCauseStats.get(cat.rootCause!) || 0;
      rootCauseStats.set(cat.rootCause!, count + 1);
    });

    console.log('\n🎯 根因分类分布:');
    Array.from(rootCauseStats.entries())
      .sort((a, b) => b[1] - a[1])
      .forEach(([cause, count]) => {
        const percentage = ((count / rootCauseCategories.length) * 100).toFixed(
          1
        );
        console.log(`  • ${cause}: ${count} 个 (${percentage}%)`);
      });

    console.log('\n✅ 漏洞分类数据导入完成！');

    return {
      success: true,
      total: result.total,
      mapped: mappedCategories.length,
      rootCause: rootCauseCategories.length
    };
  } catch (error: any) {
    console.error('❌ 漏洞分类数据导入失败:', error.message);
    throw error;
  }
}

/**
 * 验证分类数据完整性
 */
export async function validateCategories() {
  console.log('🔍 验证分类数据完整性...');

  try {
    // 检查分类总数
    const totalCount = await prisma.vulnerabilityCategory.count();
    console.log(`  📊 分类总数: ${totalCount}`);

    // 检查顶层分类
    const topLevel = await prisma.vulnerabilityCategory.count({
      where: { parentId: null }
    });
    console.log(`  📁 顶层分类: ${topLevel}`);

    // 检查有CWE映射的分类
    const withCWE = await prisma.vulnerabilityCategory.count({
      where: { cweId: { not: null } }
    });
    console.log(`  🔗 CWE映射: ${withCWE}`);

    // 检查有根因映射的分类
    const withRootCause = await prisma.vulnerabilityCategory.count({
      where: { rootCause: { not: null } }
    });
    console.log(`  🎯 根因映射: ${withRootCause}`);

    // 检查孤立分类（parentId指向不存在的分类）
    const categories = await prisma.vulnerabilityCategory.findMany({
      select: { id: true, parentId: true, name: true }
    });

    const idSet = new Set(categories.map((c) => c.id));
    const orphans = categories.filter(
      (c) => c.parentId && !idSet.has(c.parentId)
    );

    if (orphans.length > 0) {
      console.log(`  ⚠️  发现 ${orphans.length} 个孤立分类:`);
      orphans.forEach((o) => {
        console.log(`    - ${o.name} (parentId: ${o.parentId})`);
      });
    } else {
      console.log(`  ✅ 所有分类层级关系正确`);
    }

    return {
      total: totalCount,
      topLevel,
      withCWE,
      withRootCause,
      orphans: orphans.length,
      isValid: orphans.length === 0 && totalCount > 0
    };
  } catch (error: any) {
    console.error('❌ 验证失败:', error.message);
    return {
      isValid: false,
      error: error.message
    };
  }
}

// 如果直接运行此文件
if (require.main === module) {
  seedVulnerabilityCategories()
    .then(() => validateCategories())
    .finally(() => prisma.$disconnect());
}
